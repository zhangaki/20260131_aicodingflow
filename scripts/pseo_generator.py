
import os
import json
import datetime
import itertools
from trend_sentinel import slugify

# Configuration
DATA_FILE = "/Users/mac/code/super-individual/projects/20260131_seo-site/scripts/data/ai_tools.json"
OUTPUT_DIR = "/Users/mac/code/super-individual/projects/20260131_seo-site/src/content/blog"
FALLBACK_IMAGE = "/assets/blog-fallback.jpg"

def load_tools():
    with open(DATA_FILE, 'r') as f:
        return json.load(f)

import random

def get_psycho_title(tool_a, tool_b, year):
    templates = [
        f"{tool_a['name']} vs {tool_b['name']} {year}: Why Most Developers Are Making the Wrong Choice",
        f"{tool_a['name']} vs {tool_b['name']} Comparison: The One 'Hidden' Feature That Changes Everything in {year}",
        f"{tool_a['name']} vs {tool_b['name']} {year}: Is the {tool_a['pricing_starting']} Subscription Really Worth It?",
        f"Don't Buy {tool_a['name']} Until You See This {tool_b['name']} Comparison ({year} Review)",
        f"{tool_a['name']} or {tool_b['name']}? We Tested Both for 30 Days in {year}"
    ]
    return random.choice(templates)

def get_psycho_description(tool_a, tool_b, category, year):
    templates = [
        f"Stop! Before you subscribe to {tool_a['name']}, read our {year} technical breakdown. We uncovered 3 critical differences in {category} performance.",
        f"Thinking about {tool_a['name']} vs {tool_b['name']}? Learn which {category} tool actually delivers ROI in {year} and which is just hype.",
        f"The definitive {year} guide to {tool_a['name']} and {tool_b['name']}. We look at pricing, privacy, and the 'hidden' features most reviews miss."
    ]
    return random.choice(templates)

def generate_faq_schema(tool_a, tool_b):
    faq = {
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [
            {
                "@type": "Question",
                "name": f"Is {tool_a['name']} better than {tool_b['name']} in 2026?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": f"It depends on your workflow. {tool_a['name']} is superior for {tool_a['pros'][0]}, while {tool_b['name']} excels in {tool_b['pros'][0]}."
                }
            },
            {
                "@type": "Question",
                "name": f"Which is cheaper, {tool_a['name']} or {tool_b['name']}?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": f"{tool_a['name']} starts at {tool_a['pricing_starting']}, compared to {tool_b['name']} at {tool_b['pricing_starting']}."
                }
            }
        ]
    }
    return json.dumps(faq, indent=2)

def generate_comparison_text(tool_a, tool_b):
    year = datetime.datetime.now().year
    
    text = f"""## The {year} Showdown: {tool_a['name']} vs {tool_b['name']}

Choosing between **{tool_a['name']}** and **{tool_b['name']}** is a dilemma most modern teams face. While both leverage AI, their philosophies on **Machine-Human Collaboration** are fundamentally different.

### Feature Comparison At a Glance

| Feature | {tool_a['name']} | {tool_b['name']} |
| :--- | :--- | :--- |
| **Category** | {tool_a['category']} | {tool_b['category']} |
| **Starting Price** | {tool_a['pricing_starting']} | {tool_b['pricing_starting']} |
| **Best For** | {tool_a['best_for']} | {tool_b['best_for']} |

### Why Choose {tool_a['name']}?
{tool_a['name']} is the preferred choice for those who value **{tool_a['pros'][0]}**. Its core strength lies in its {tool_a['key_features'][0]}, making it indispensable for {tool_a['best_for']}.

### Why Choose {tool_b['name']}?
On the other hand, {tool_b['name']} excels in **{tool_b['pros'][0]}**. If your workflow requires {tool_b['key_features'][0]}, then {tool_b['name']} is the clear winner for {tool_b['best_for']}.

### The "Hidden" Difference (The Reasoner Test)
In our internal tests, we found that {tool_a['name']} handles **Contextual Ambiguity** slightly better, while {tool_b['name']} wins on **Execution Velocity**. For a US-based SaaS team, {tool_a['name']} often yields a better long-term ROI in the Knowledge Graph.

### Which One Should You Buy?
- **Choose {tool_a['name']} if**: You need {tool_a['pros'][1]}.
- **Choose {tool_b['name']} if**: You prioritize {tool_b['pros'][1]}.

### Frequently Asked Questions
<script type="application/ld+json">
{generate_faq_schema(tool_a, tool_b)}
</script>

---
*Generated by PSEO Engine V2 - Optimized for US/UK High-CTR Clicks.*
"""
    return text

def run_pseo():
    tools = load_tools()
    count = 0
    
    # Generate all pairs
    for tool_a, tool_b in itertools.combinations(tools, 2):
        # Only compare tools in same category for relevance (optional, but better for SEO)
        # However, cross-category comparisons (e.g., Coding vs LLM) are also long-tail gold
        
        year = datetime.datetime.now().year
        slug = f"{slugify(tool_a['name'])}-vs-{slugify(tool_b['name'])}-{year}"
        filename = f"{slug}.md"
        filepath = os.path.join(OUTPUT_DIR, filename)
        
        title = get_psycho_title(tool_a, tool_b, year)
        description = get_psycho_description(tool_a, tool_b, tool_a['category'], year)
        date_str = datetime.datetime.now().strftime("%b %d %Y")
        
        content = f"---\ntitle: \"{title}\"\ndescription: \"{description}\"\npubDate: \"{date_str}\"\nheroImage: \"{FALLBACK_IMAGE}\"\n---\n\n{generate_comparison_text(tool_a, tool_b)}\n"
        
        with open(filepath, 'w') as f:
            f.write(content)
        
        print(f"Generated PSEO: {filename}")
        count += 1
        
    print(f"PSEO Batch Complete. Generated {count} comparison pages.")

if __name__ == "__main__":
    run_pseo()
